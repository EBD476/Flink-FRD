/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package my.flink.project;


import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.api.java.DataSet;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.api.java.ExecutionEnvironment;
import org.apache.flink.util.Collector;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.api.java.utils.ParameterTool;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.connector.file.src.reader.TextLineFormat;
import org.apache.flink.connector.file.src.FileSource;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;


import org.apache.flink.api.common.io.FileInputFormat;
import org.apache.flink.api.java.io.TextInputFormat;
import org.apache.flink.api.java.io.TextValueInputFormat;
import org.apache.flink.core.fs.Path;

import java.util.Map;
import java.util.List;
import java.util.Arrays;

public class App {
    public String getGreeting() {
        return "WordCount Example";
    }

    public static void main(String[] args) {
        // System.out.println(new App().getGreeting());

        // final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        // ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();


        // TextInputFormat format = new TextInputFormat(new Path("./alarmed_cust.txt"));
        // DataStream<String> alarmedCustomers = env.readFile(format, "./alarmed_cust.txt");

        // DataStream<String> alarmedCustomers = env.readTextFile("./test.txt");

        // try{
        //     String inputFilePath = "./test.txt";  // replace with your path

        //     // Use TextInputFormat for reading the text file
        //     TextInputFormat format = new TextInputFormat(new Path(inputFilePath));
        //     DataStream<String> alarmedCustomers = env.readFile(format, inputFilePath);

        
        // //  DataStream<String> alarmedCustomers = env.fromElements("Hello Flink", "Hello VSCode");
        // // .map(new ReplaceMapper());

        // // Map each line to the integer value 1
        // DataStream<Integer> ones = alarmedCustomers.map(new MapFunction<String, Integer>() {
        //     @Override
        //     public Integer map(String value) {
        //         return 1;
        //     }
        // });

        // DataStream<String> source = env.fromElements("hello", "world");
        //   DataStream<String> ones = source.map(new MapFunction<String, String>() {
        //     @Override
        //     public String map(String value) {
        //         return "1";
        //     }
        // });
        // source.map(value -> value.toUpperCase());

    //    DataStream<Integer> numbers = env.fromElements(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
    //     // Transformation: Square each number
    //    DataStream<Integer> squaredNumbers = numbers.map(new SquareMapper());

    //    // Output the squared numbers
    //    squaredNumbers.print();    

//     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

    
//     // DataStream<String> text = env.readFile("file:///test.txt");
//     String filePath = "test.txt";

//     final FileSource<String> source =
//   FileSource.forRecordStreamFormat(new TextLineFormat(),  new Path(filePath))
//   .build();
// final DataStream<String> stream =
//   env.fromSource(source, WatermarkStrategy.noWatermarks(), "file-source");

//   DataStream<AlarmedCustomer> alarmedCustomers =	 stream
//   .map(new MapFunction<String, AlarmedCustomer>() {
//       public AlarmedCustomer map(String value)
//       {
//          return  new AlarmedCustomer(value);
//       }
//     });


    //.readTextFile("file:///test.txt");

    
    //  text = env.fromElements("Hello Flink", "Hello VSCode");    
           
    //    DataStream<Tuple2<String, Integer>> counts =
    //    split up the lines in pairs (2-tuples) containing: (word,1)
    //    stream.flatMap(new Tokenizer2());
    //    group by the tuple field "0" and sum up tuple field "1"
    //    .groupBy(0)
    //    .sum(1);

    

        //   try {
        //     // counts.writeAsText("output.txt");
        //     alarmedCustomers.print();
        //     env.execute("Alarmed Customers");
        // } catch (Exception e) {            
        //     e.printStackTrace();
        // }

        // }catch(Exception e){

        // }

      

        // DataStream<Integer> lineCount = ones.reduce((integer, t1) -> integer + t1);


        // .map(new MapFunction<String, AlarmedCustomer>(){
        //     public AlarmedCustomer map(String value)
        //     {
        //       return new AlarmedCustomer(value);
        //     }

        // });

        // DataStream<Tuple2<String, String>> data = env.socketTextStream("localhost", 9999)
        //            .map(new MapFunction<String, Tuple2<String, String>>()
        // {
        //     public Tuple2<String, String> map(String value)
        //     {
        //         String[] words = value.split(",");            
        //         return new Tuple2<String, String>(words[3], value); //{(id_347hfx) (HFXR347924,2018-06-14 23:32:23,Chandigarh,id_347hfx,hf98678167,123302773033,774
        //     }
        // });

        // alarmedCustomers.print();
        // alarmedCustomers.writeAsText("output.txt");

        // try {
        //     env.execute("Alarmed Customers");
        // } catch (Exception e) {            
        //     e.printStackTrace();
        // }

        new Bank().checkAlarmedCustomers();

    // 1   StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();


    //    DataStream<String> text = env.fromElements("Hello Flink", "Hello VSCode");

        // Input data
    //    DataStream<Integer> numbers = env.fromElements(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
    //     // Transformation: Square each number
    //    DataStream<Integer> squaredNumbers = numbers.map(new SquareMapper());

    //    // Output the squared numbers
    //    squaredNumbers.print();

        // DataStream<Tuple2<String, Integer>> counts = text
        //     .flatMap(new Tokenizer())
        //     .keyBy(value -> value.f0)
        //     .sum(1);
        
        // counts.print();

        //1 DataStream<String> dataStream = env.socketTextStream("localhost", 9999)
        // .map(new ReplaceMapper());        


        // DataStream<Tuple2<String, Integer>> dataStream = env.socketTextStream("localhost", 9999)
        // .flatMap(new Splitter())
        // .keyBy(0)
        // .sum(1);

        // DataStream<Tuple2<String, Integer>> dataStream = env
        // .socketTextStream("localhost", 9999);
        //.flatMap(new Splitter())        
        //.keyBy(0)
        //.timeWindow(Time.seconds(5))
        //.sum(1);


        //1 dataStream.print();

        // try {
        //     env.execute("WordCount Example");
        // } catch (Exception e) {            
        //     e.printStackTrace();
        // }

    }

    public static final class Tokenizer implements FlatMapFunction<String, Tuple2<String, Integer>> {
        @Override
        public void flatMap(String value, Collector<Tuple2<String, Integer>> out) {
            String[] tokens = value.toLowerCase().split("\\W+");
            for (String token : tokens) {
                if (token.length() > 0) {
                    out.collect(new Tuple2<>(token, 1));
                }
            }
        }
    }

    
// User-defined functions
public static class Tokenizer2 implements FlatMapFunction<String, Tuple2<String, Integer>> {

    @Override
    public void flatMap(String value, Collector<Tuple2<String, Integer>> out) {
        // normalize and split the line
        String[] tokens = value.toLowerCase().split("\\W+");

        // emit the pairs
        for (String token : tokens) {
            if (token.length() > 0) {
                out.collect(new Tuple2<String, Integer>(token, 1));
            }   
        }
    }
}

      /**
     * Mapper class to square a number
     */
    public static final class SquareMapper implements MapFunction<Integer, Integer> {
        @Override
        public Integer map(Integer value) {
            return value * value;
        }
    }


    public static final class ReplaceMapper implements MapFunction<String, String> {
        @Override
        public String map(String value) {
            return value.replace("INFO", "ERROR");
        }
    }

    public static class Splitter implements FlatMapFunction<String, Tuple2<String, Integer>> {
        @Override
        public void flatMap(String sentence, Collector<Tuple2<String, Integer>> out) throws Exception {
           for (String word: sentence.split(" ")) {
              out.collect(new Tuple2<String, Integer>(word, 1));
           }
        }
     }
}
